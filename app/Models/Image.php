<?php

namespace App\Models;

use App\Exceptions\AppException;
use App\Models\Base\BaseModel;
use App\Utils\DateTimeUtil;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class Image extends BaseModel
{

    private $temp = 'temp';

    //upload image base on base64
    public function base64Upload($encodeString, $folder)
    {
        try {
            // Extension support
            $supportExt = ['jpeg', 'png'];

            // Initial s3
            $client = Storage::disk('s3')
                ->getDriver()
                ->getAdapter()
                ->getClient();

            // clear data string
            $data = preg_replace(
                '#^data:image/\w+;base64,#i',
                '', $encodeString
            );

            // decode image data
            $imageData = base64_decode($data);

            // get mime type
            $mime_type = finfo_buffer(
                finfo_open(),
                $imageData,
                FILEINFO_MIME_TYPE
            );

            // in $imageData is saved the string generated by service A
            if (!$imageData) {
                throw AppException::flash(
                    Response::HTTP_BAD_REQUEST,
                    "invalid image data."
                );
            }

            // get extension
            $ext = explode('/', $mime_type)[1];
            if (!in_array($ext, $supportExt)) {
                throw AppException::flash(
                    Response::HTTP_BAD_REQUEST,
                    "File type is not supported."
                );
            }

            // change type
            if ($ext == 'jpeg') $ext = 'jpg';

            // $contentType taken from switch function on $ext
            // for example 'image/png'
            $filename = sha1(uniqid()) . '.' . $ext;

            $full_filename = $this->generatePath($folder) . '/' . $filename;

            $tmpFName = tempnam(
                "/tmp",
                "image_to_upload"
            );

            $populated = file_put_contents($tmpFName, $imageData);

            if (!$populated) {
                //handle write failures
                throw AppException::flash(
                    Response::HTTP_UNPROCESSABLE_ENTITY,
                    "Writing image failed."
                );
            }

            $input = [
                'Bucket' => env('S3_BUCKET'),
                'Key' => $full_filename,
                'SourceFile' => $tmpFName,
                'ContentType' => $mime_type
            ];

            $command = $client->PutObject($input);

//        $request = $client->createPresignedRequest($command, '+20 minutes');

            $input['Key'] = str_replace(
                $this->temp . '/',
                '',
                $full_filename
            );

            Log::info(
                json_encode(
                    'upload image to Aws, with response' .
                    $command)
            );

            return [
                "request" => $input,
                "response" => $command
            ];

        } catch (\Exception $e) {
            throw $e;
        }
    }

    public function removeObject($key, $isRestrict = true)
    {
        try {

            if (strpos($key, env('S3_URL')) === false) {
                return null;
            }

            $s3 = Storage::disk('s3');

            if ($isRestrict && !$s3->has(
                    str_replace(env('S3_URL'),
                        '',
                        $key))) {

                throw AppException::flash(
                    Response::HTTP_UNPROCESSABLE_ENTITY,
                    "media does not found in aws"
                );
            }

            $res = $s3->delete(str_replace(
                env('S3_URL'),
                '',
                $key));

            return $res;

        } catch (\Exception $e) {
            throw  $e;
        }
    }

    public function removeObjectBulk($keys = array())
    {
        return $s3 = Storage::disk('s3')->delete($keys);
    }

    //copy file to the right path (from temp path)
    public function copyBulk($keys)
    {
        array_map(function ($k) {
            if (strpos($k, env('S3_URL')) !== false) {
                $key = str_replace(env('S3_URL'), '', $k);

                $oldKey = $this->temp . '/' . $key;//old File Location
                $newKey = $key;

                //check existing temp string
                if (strpos($key, $this->temp) !== false) {
                    $oldKey = $key;
                    $newKey = str_replace('temp/', '', $key);
                }

                //copy it
                Storage::disk('s3')
                    ->copy($oldKey, $newKey);
            }
        }, $keys);
    }

    //move file to the right path
    public function moveTmpToRightPathBulk($keys)
    {
        array_map(function ($k) {
            if (strpos($k, env('S3_URL')) !== false) {
                $key = str_replace(env('S3_URL'), '', $k);
                $disk = Storage::disk('s3');

                $oldKey = $this->temp . '/' . $key;//old File Location
                $newKey = $key;

                //check existing temp string
                if (strpos($key, $this->temp) !== false) {
                    $oldKey = $key;
                    $newKey = str_replace('temp/', '', $key);
                }

                //move it
                $disk->move(
                    $oldKey,
                    $newKey
                );

            }
        }, $keys);
    }

    public function removeKeyTemp($keys)
    {
        array_map(function ($k) {
            if (strpos($k, env('S3_URL')) !== false) {
                $key = str_replace(env('S3_URL'), '', $k);
                $disk = Storage::disk('s3');

                //move it
                $disk->delete($key);

            }
        }, $keys);
    }

    public function removeTemp()
    {
        Storage::disk('s3')->deleteDirectory($this->temp);
    }

    /**@deprecated */
    public function generatePath($folder)
    {
        $orgKey = sha1('52b202878635bd08534c58b0d7' . AuthToken::info()->organizationId);
        return $this->temp . '/' . $orgKey . '/' . $folder . '/' . bin2hex(random_bytes(7)) . DateTimeUtil::currentMicroSecond();
    }

    public function getCredential($folder)
    {

        $s3Bucket = env('S3_BUCKET');
        $s3Region = env('S3_REGION');
        $s3Key = env('S3_KEY');
        $s3Secret = env('S3_SECRET');

        $orgId = AuthToken::info()->organizationId;
        $orgKey = sha1('52b202878635bd08534c58b0d7' . $orgId);
        $acl = 'public-read';
        $algorithm = "AWS4-HMAC-SHA256";
        $service = "s3";
        $date = gmdate("Ymd\THis\Z");
        $shortDate = gmdate("Ymd");
        $requestType = "aws4_request";
        $expires = "86400"; // 24 Hours
        $successStatus = "201";
        $url = "//{$s3Bucket}.{$service}-{$s3Region}.amazonaws.com";
        $key = $orgKey . '/' . $folder . '/' . bin2hex(random_bytes(7)) . DateTimeUtil::currentMicroSecond() . '/';

        // Step 1: Generate the Scope
        $scope = [
            $s3Key,
            $shortDate,
            $s3Region,
            $service,
            $requestType
        ];
        $credentials = implode('/', $scope);

        // Step 2: Making a Base64 Policy
        $policy = [
            'expiration' => gmdate('Y-m-d\TG:i:s\Z', strtotime('+6 hours')),
            'conditions' => [
                ['bucket' => $s3Bucket],
                ['acl' => $acl],
                ['starts-with', '$key', $key],
                ['starts-with', '$Content-Type', ''],
                ['success_action_status' => $successStatus],
                ['X-amz-credential' => $credentials],
                ['X-amz-algorithm' => $algorithm],
                ['X-amz-date' => $date],
                ['X-amz-expires' => $expires],
            ]
        ];

        $base64Policy = base64_encode(json_encode($policy));

        // Step 3: Signing your Request (Making a Signature)
        $dateKey = hash_hmac('sha256', $shortDate, 'AWS4' . $s3Secret, true);
        $dateRegionKey = hash_hmac('sha256', $s3Region, $dateKey, true);
        $dateRegionServiceKey = hash_hmac('sha256', $service, $dateRegionKey, true);
        $signingKey = hash_hmac('sha256', $requestType, $dateRegionServiceKey, true);

        $signature = hash_hmac('sha256', $base64Policy, $signingKey);

        // Step 4: Build form inputs
        // This is the data that will get sent with the form to S3
        $inputs = [
            'key' => $key,
            'acl' => $acl,
            'Content-Type' => '',
            'success_action_status' => $successStatus,
//            'X-amz-meta-tag' => '',
            'X-amz-credential' => $credentials,
            'X-amz-algorithm' => $algorithm,
            'X-amz-date' => $date,
            'X-amz-expires' => $expires,
            'X-amz-signature' => $signature,
            'Policy' => $base64Policy,
        ];

        return array('url' => $url, 'input' => $inputs);

    }

    public static function inst()
    {
        return new self();
    }

    public function populate($request = [], BaseModel $model = null)
    {
        if (!is_null($model))
            $model = self::inst();

        return $model;
    }

    public function getRightPath($key)
    {
        if (strpos($key, $this->temp) !== false) {
            return str_replace('temp/', '', $key);
        }

        return $key;
    }
}